[
    {
        "id": 0,
        "titleName": "Home-page",
        "text": "\n        <h2>JavaScript</h2>\n        <p>\n        JavaScript is a dynamic computer programming language. \n        <br>In dynamically typed languages, type checks is performed during runtime, meaning that you can assign multiple things to the same variable.\n        <br><figure class=\"figure\"><img class=\"figure-img img-fluid rounded\" src=\"../components/images/DynamicType.png\"></figure>\n        </p>\n        \n        <h2>Node.js</h2>\n        <p>Node.js is an open-source, JavaScript runtime environment, that uses chromes V8 JavaScript engine to make it possible to run network applications using JavaScript.\n        <br>To run a Node application you run the following command: <br><i>node [JavaSript file name]</i><br>Usually the script is called app.js</p>\n        \n        <h4>Package.json</h4>\n        <p>Package.json is a fundamental part of Node.js ecosystem, package.json is used to store metadata about the project as well as a list of dependencies and scripts.\n        <br>Example of how a package.json might look:\n        <br><figure class=\"figure\"><img class=\"figure-img img-fluid rounded\" src=\"../components/images/jsonpackage.png\"></figure>\n\n        <br><b>Meta data:</b> is data about the application, e.g. \"name\" or \"type\".\n\n        <br><b>Dependencies:</b> can be a code library or a package that is needed for the node application to work. When typing <i>npm install</i> in the terminal, package.json is scanned and the relevant files are installed/downloaded.\n        <br>In the picture above we see a <i>key:value</i> pair under dependencies, this indicates that the application uses <i><a href=\"express\" class=\"link-primary\">express</a></i> since that is the key, the value is the number that indicates what version of express the application uses.\n        \n        <br><b>Scripts:</b> are custom scripts that can be define. \n        <br>In this project under the scripts section there is a script called <i>\"start-prod\"</i>, so when <i>npm run start-prod</i> is run in the console, it runs <i>node app.js</i>.\n        </p>\n\n        <h2>Nodemon</h2>\n        <p>nodemon is a tool that helps develop Node.js based applications by automatically restarting the node application when certain files are changed depending on what nodemon is supposed to look out for.\n        <br>Nodemon does not change the way you have to code/develop node applications. \n        <br>In order to use nodemon we have to change the command for when running a node application: \n        <br><b>Command without using nodemon:</b> <i>node [JavaSript file name]</i></b>\n        <br><b>Command line when using nodemon:</b> <i>nodemon [JavaSript file name]</i></p>\n        "
    },
    {
        "id": 1,
        "titleName": "Express-page",
        "text": "        <h2>Express framework</h2>        <p>Express is a web framework that helps building web applications and APIs using Node.js </p>        <h6>REST API</h6>        <p>When making APIs there are certain convictions and best practices one should keep in mind.         Some of those practices is how to name endpoints and the order of ones HTTP request methods shoulde be in the backend.        When naming endpoints it should be kept to nouns and avoid unnecessary things such as verbs, the reasoning is to make understandable for everyone and easy to read.        <br>Example if you want to get at list of users from you server the endpoint should be <i>https://example.com/users</i> and not <i>https://example.com/getUsers</i>        this is because of the CRUD functionality that HTTP request already have, so it should be implicit what an endpoint does depending on the HTTP request it invokes.        <br><b>Oder of HTTP request methods:</b>        <br><ul>        <li>GET (all)</li>        <li>GET (Single)</li>        <li>POST</li>        <li>PUT</li>        <li>PATCH</li>        <li>DELETE</li>        </ul>        </p>        <h2>Expess routing/routers</h2>        <p>Routing is about how an application's endpoint reponse to a request from the client.         <br>In Express a route is done by calling a method on the Express <i>app</i> object, the method has to correspond to one of the HTTP methods,         so for a GET requests it would be <i>app.get()</i> and for POST requests <i>app.post()</i>        <br><figure class=\"figure\">        <figcaption class=\"figure-caption\">Simple route:</figcaption>        <img class=\"figure-img img-fluid rounded\" src=\"../components/images/SimpleRoute.png\">        </figure>        <br>        <h5>Callback function</h5>        <p>A callback or callback function is any reference to executable code that is passed as an argument.         <br>This can be seen in the picture above that, when application recieves a request for that endpoint,         it calls the callback function that sends a reponse back in this case it is an object containing a message.        </p>        <h5>express.Router</h5>        <p>        In express it is possible to create your own router using the express.Router function.         This is done by creating a separate JavaSript file and importing <i>Router</i> from express,         then define some routes it should use after that export it so it can be used by the main app.        <br><figure class=\"figure\">        <figcaption class=\"figure-caption\">Documentaion router:</figcaption>        <img class=\"figure-img img-fluid rounded\" src=\"../components/images/docRouter.png\">        </figure>        <br><figure class=\"figure\">        <figcaption class=\"figure-caption\">app.js import and use of router:</figcaption>        <img class=\"figure-img img-fluid rounded\" src=\"../components/images/importAndUseRouter.png\">        </figure>        <br>The app is now able to handle request that are hitting the endpoints in the documentation router.        </p>        </p>        "
    },
    {
        "id": 2,
        "titleName": "Rendering-page",
        "text": "        <h2>Rendering</h2>        <h3>Server side rendering</h3>        <p>        Server side rendering <i>(SSR)</i> is when a user makes a request for a page, the server prepares the necessary data needed and sends it back to the user's machine.         Once the data is received the browser constucts for it to be displayed.         One of the reasons it is prefered to use SSR is because it lets search engines crawl the site for better Search Engine Optimization <i>(SEO)</i>.        <br>        <figure class=\"figure\">        <b>Example of SSR using express:</b>        <figcaption class=\"figure-caption\">Imports file sytem <i>(fs)</i> to read the html files.        <br> Function that returns the complete string based on path and with option to manipulate that content:</figcaption>        <img class=\"figure-img img-fluid rounded\" src=\"../components/images/ssr.png\">        </figure>        <br><figure class=\"figure\">        <figcaption class=\"figure-caption\">Replacing the value tab title and content with data from documentaion:</figcaption>        <img class=\"figure-img img-fluid rounded\" src=\"../components/images/replaceInRender.png\">        </figure>        <br><figure class=\"figure\">        <figcaption class=\"figure-caption\">GET request that sends the assembled page:</figcaption>        <img class=\"figure-img img-fluid rounded\" src=\"../components/images/sendHomepage.png\">        </figure>        </p>        <h3>Client side rendering</h3>        <p>        Client side rendering is about rendering content in the browser using JavaScript.         This means that instead of receiving a HTML that contains all the content, a bare-bones HTML with JavaScript file is received and the JavaScript is then responsible for rendering the rest of the site using the browser.        With Client side rendering the initial page load is/can be a bit slow, however every subsequent page load is extremly fast since communication with the server only happens to get run-time data.        </p>        "
    }
]